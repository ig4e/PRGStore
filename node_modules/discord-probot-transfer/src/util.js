var Event = require("events");
///// Error log /////
var error = (err) => {
  throw new Error(err);
};
/////

class Transfer extends Event {
  ////
  constructor(client, { fetchGuilds = false, data = [] } = {}) {
    if (!client || typeof client != "object")
      return error("can't create transfer without discord client!");
    if (
      data &&
      Array.isArray(data) &&
      data.length &&
      !data.every((d) => d.guildId)
    )
      return error(
        "[guildId] is required in data option, please check up your code!"
      );

    try {
      super();
      this.client = client;
      this.fetchGuilds = fetchGuilds;
      this.probot = "282859044593598464";
      this.probotPrime = "567703512763334685";
      this.underCollect = [];
      this.client.vers = this.client.options.http.version;
      this.data =
        !data || !Array.isArray(data) || !data.length
          ? []
          : [...new Set(data.map((d) => Transfer.mapData(d)))];
      this.client.on(
        `${this.client.vers == "9" ? "messageCreate" : "message"}`,
        (message) => this.checkMsg(message)
      );
    } catch (e) {
      try {
        this.emit("error", null, e);
      } catch {}
    }
  }

  ////
  static mapData({
    guildId,
    probotId = "282859044593598464",
    owners = [],
    fetchMembers = false,
  } = {}) {
    return {
      guildId,
      probotId,
      owners:
        typeof owners == "string"
          ? [...new Set(owners.split(","))]
          : [...new Set(owners)],
      fetchMembers: typeof fetchMembers != "boolean" ? false : fetchMembers,
    };
  }

  ////
  tax(amount, size = 0) {
    if (!amount || isNaN(amount))
      return error("credit amount can't be empty or string !");
    size = size < 0 ? 0 : Number(size);
    var withTax = Math.ceil(amount / 0.95),
      tax = Math.ceil(amount * (5 / 100));
    var data = {
      amount,
      withTax,
      tax,
      afterTax: amount - tax,
      mediator: [Math.ceil(withTax / 0.95)],
    };

    for (let i = 0; i < size; i++) {
      data.mediator.push(Math.ceil(Number(data.mediator.slice(-1)) / 0.95));
    }
    data.mediator.reverse();
    return data;
  }

  ////
  getInfo(message, owners = [], force = false) {
    if (!message.author.bot || !message.content.startsWith("**:moneybag:"))
      return null;
    owners = typeof owners == "string" ? owners.split(",") : owners;
    //
    if (!owners.length) {
      var info = this.data.find((u) => u.guildId == message.guild.id);
      if (info) owners = info.owners;
    }
    //
    if (owners.length && !force) {
      if (!owners.includes(message.mentions.users.first().id)) return null;
    }
    //
    var string = message.content,
      price = string.split("$")[1].split("`")[0],
      member;
    if (message.mentions.repliedUser) {
      member = message.guild.members.cache.find(
        (u) => u.id == message.mentions.repliedUser.id
      );
    } else {
      var begin = string.indexOf("|"),
        end = string.lastIndexOf(","),
        user = string.slice(begin + 2, end),
        member = message.guild.members.cache.find(
          (u) => u.user.username == user
        );
    }
    var receiver = message.mentions.members.first();
    //
    return {
      price,
      member,
      receiver,
      owner: owners.includes(receiver.user.id),
      fullPrice: Math.ceil(price / 0.95),
    };
  }

  ////
  addToCollect(message) {
    this.underCollect.push({
      userId: message.author.id,
      channelId: message.channel.id,
    });
  }

  ////
  removeFromCollect(message) {
    var Index = this.underCollect.findIndex(
      (u) =>
        `${u.userId != message.author.id && u.channelId != message.channel.id}`
    );
    if (Index < 0) return;
    this.underCollect = this.underCollect.filter((a, i) => i != Index);
  }

  ///
  check(message, member) {
    return this.underCollect.find(
      (u) =>
        u.userId == `${member ? member.user.id : message.author.id}` &&
        u.channelId == message.channel.id
    );
  }

  ////
  create({
    guildId,
    probotId = this.probot,
    owners = [],
    fetchMembers = false,
  } = {}) {
    if (!guildId || isNaN(guildId))
      return error("[guildId] required and can't be string !");
    owners = typeof owners == "string" ? owners.split(",") : owners;
    fetchMembers = typeof fetchMembers != "boolean" ? false : fetchMembers;

    if (this.data.find((d) => d.guildId == guildId))
      return this.edit(guildId, { probotId, owners, fetchMembers });
    return this.data.push({ guildId, probotId, owners, fetchMembers });
  }

  ////
  delete(guildId) {
    this.data = this.data.filter((d) => d.guildId != guildId);
  }

  ////
  edit(
    guildId,
    { probotId = this.probot, owners = [], fetchMembers = false } = {}
  ) {
    var gData = this.data.findIndex((d) => d.guildId == guildId);
    owners = typeof owners == "string" ? owners.split(",") : owners;
    fetchMembers: typeof fetchMembers != "boolean" ? false : fetchMembers;
    if (gData < 0)
      return this.create({ guildId, probotId, owners, fetchMembers });
    return (this.data[gData] = { guildId, probotId, owners, fetchMembers });
  }
  ////
  getData() {
    return this.data;
  }

  ///
  checkMsg(message) {
    //
    if (!message.guild) return;
    message.guild.channel = message.channel;
    try {
      var owners = [],
        probotId = this.probot,
        fetch = false;

      if (this.data.length) {
        var info = this.data.find((u) => u.guildId == message.guild.id);
        if (!info && !this.fetchGuilds) return;
        owners = info ? info.owners : owners;
        probotId = info ? info.probotId : probotId;
        fetch = info ? info.fetchMembers : fetch;
      } else {
        var prime = message.guild.members.cache.get(this.probotPrime);
        if (prime) probotId = this.probotPrime;
      }

      if (message.author.id != probotId) return;

      if (!message.content) return;
      //

      //
      var data = this.getInfo(message, owners, fetch);
      if (!data) return;
      //

      if (this.check(message, data.member)) return;
      //
      this.emit("transfered", message.guild, data);
    } catch (e) {
      try {
        this.emit("transfered", message.guild, null, e);
        this.emit("error", message.guild, e);
      } catch {}
    }
  }

  ///
  async collect(
    message,
    { price, owners = [], time, userId, probotId, fullPrice = false } = {}
  ) {
    try {
      if (price && !Number(price))
        return error("[price]  must be number only!");

      if (this.check(message)) return;

      if (!probotId) {
        var bot = this.data.find((u) => u.guildId == message.guild.id);
        probotId = bot ? bot.probotId : this.probot;
      }

      fullPrice = typeof fullPrice != "boolean" ? false : fullPrice;
      this.addToCollect(message);
      var filter;
      //
      if (userId) {
        filter = (m) =>
          m.author.id == probotId &&
          this.getInfo(m, owners) &&
          this.getInfo(m, owners).member.user.id == userId;
      } else if (!userId && price) {
        filter = (m) =>
          m.author.id == probotId &&
          this.getInfo(m, owners) &&
          this.getInfo(m, owners).price ==
            `${fullPrice ? price : this.tax(price).afterTax}`;
      } else {
        filter = (m) => m.author.id == probotId && this.getInfo(m, owners);
      }
      //
      try {
        var collected;
        if (this.client.vers == 9)
          collected = await message.channel.awaitMessages({
            filter,
            max: 1,
            time,
            errors: ["time"],
          });
        else
          collected = await message.channel.awaitMessages(filter, {
            max: 1,
            time,
            errors: ["time"],
          });

        if (collected) {
          this.removeFromCollect(message);
          var cData = this.getInfo(collected.first(), owners);
          if (!cData)
            return {
              status: false,
              error: { message: `I can't find who transfer!` },
            };

          cData.status = price
            ? cData.price >= `${fullPrice ? price : this.tax(price).afterTax}`
              ? true
              : false
            : true;
          cData.priceTransfered = cData.price;
          if (price) {
            cData.fullPrice = Math.ceil(cData.price / 0.95);
            cData.priceRequired = `${
              fullPrice ? price : this.tax(price).afterTax
            }`;
            cData.priceTotal = Math.ceil(price / 0.95);
          }
          delete cData.price;

          return cData;
        }
      } catch (e) {
        this.removeFromCollect(message);
        return {
          status: false,
          error: { message: `Time end` },
        };
      }
    } catch (e) {
      this.removeFromCollect(message);
      return error(e);
    }
    ///
  }
  ///
}

var tax = (amount, size = 0) => {
    if (!amount || isNaN(amount))
      return error("credit amount can't be empty or string !");
    size = size < 0 ? 0 : Number(size);
    var withTax = Math.ceil(amount / 0.95),
      tax = Math.ceil(amount * (5 / 100));
    var data = {
      amount,
      withTax,
      tax,
      afterTax: amount - tax,
      mediator: [Math.ceil(withTax / 0.95)],
    };

    for (let i = 0; i < size; i++) {
      data.mediator.push(Math.ceil(Number(data.mediator.slice(-1)) / 0.95));
    }
    data.mediator.reverse();
    return data;
  },
  Probot = (client, options) => new Transfer(client, options);

module.exports = {
  Probot,
  tax,
};
